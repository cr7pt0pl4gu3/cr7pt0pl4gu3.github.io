{"/":{"title":"cr7pt0pl4gu3 blog","content":"# Daniil Nababkin\n![[assets/photo.jpg]]\n## Research\n- [[research/MacOS/Reverse Engineering and Demystifying *OS Private Frameworks|Reverse Engineering and Demystifying *OS Private Frameworks]]\n- [[research/MacOS/ObjectiveC dylib Reverse Engineering gigavaxxed with Binary Ninja LLDB|Objective-C .dylib Reverse Engineering \"gigavaxxed\" with Binary Ninja \u0026 LLDB]]\n## Certifications\n- [OSCE3](https://www.credential.net/d2416d55-c97d-4484-a54a-590fbe82fa93) | [OSCP](https://www.credential.net/c644175d-738f-4f7f-b835-fb79118c7162) | [OSED](https://www.credential.net/e62f5915-2126-4d37-8980-d9c3cb4b2b75) | [OSEP](https://www.credential.net/fabc5f30-7e00-4631-9b00-4a9621534180) | [OSWE](https://www.credential.net/3001de48-f76b-4a80-a2e3-5d34a05637e9)\n- [HtB Cybernetics | Red Team Operator Level II](https://cr7pt0pl4gu3.github.io/assets/Cybernetics.pdf)\n- [VHL Advanced+ Certificate of Completion](https://cr7pt0pl4gu3.github.io/assets/VHL_plus.pdf) | [VHL Certificate of Completion](https://cr7pt0pl4gu3.github.io/assets/VHL.pdf)\n- [Cybersecurity Essentials (Cisco)](https://www.credly.com/badges/4e311c24-4173-4ea7-811f-c2bd775c6f89/public_url \"https://www.credly.com/badges/4e311c24-4173-4ea7-811f-c2bd775c6f89/public_url\")\n- [II place at the National Hackathon on Cyber Security of Ukraine (OSINT)](https://cr7pt0pl4gu3.github.io/assets/HXK3.pdf)","lastmodified":"2022-04-29T17:13:11.016003953Z","tags":null},"/research/MacOS/ObjectiveC-dylib-Reverse-Engineering-gigavaxxed-with-Binary-Ninja-LLDB":{"title":"Untitled Page","content":"# Objective-C .dylib Reverse Engineering \"gigavaxxed\" with [Binary Ninja](https://binary.ninja) \u0026 [LLDB](https://lldb.llvm.org)\n## First, the results, then - many words\nPS. Warning, this post contains lots of black \u0026 unfunny IT humor\n### The complexity of this technique\nJust press a button (yep, that's it):\n![[research/MacOS/assets/Pasted image 20220429151302.png]]\n### With vs Without\n#### Without the plugin (Pseudo C)\n![[research/MacOS/assets/Pasted image 20220429153158.png]]\n#### With the plugin (Pseudo C)\nNote that selectors are displayed as comments, before the objc_msgSend call. Objective-C classes, strings, protocols, etc are displayed as well:\n![[research/MacOS/assets/Pasted image 20220429152417.png]]\n#### Without the plugin (Disassembly)\n![[research/MacOS/assets/Pasted image 20220429153058.png]]\n#### With the plugin (Disassembly)\nHonestly, the annotations \u0026 namings are close to being perfect:\n![[research/MacOS/assets/Pasted image 20220429152541.png]]\n### Impressive, but I use [iDa pRo](https://hex-rays.com/ida-pro/)\nGood luck on that (7.7.211224 [IDA Freeware](https://hex-rays.com/ida-free/) below):\n![[research/MacOS/assets/Pasted image 20220429155934.png]]\n\n![[Pasted image 20220429160132.png]]\n## Backstory\nThis story happened in April 2022, while I was attending the [Program Analysis for Vulnerability Research](https://margin.re/trainings/article.aspx?id=6) training by [Margin Research](https://margin.re) \u0026 [Vector35](https://vector35.com).\n\nI was sitting in my chair thinking about reverse engineering one of Apple's Private Frameworks (you read it right, \"thinking\"). Casually loaded it in [Binary Ninja](https://binary.ninja), selected the [Objective-Ninja](https://github.com/jonpalmisc/ObjectiveNinja) workflow, and got greeted with this:\n[![image](https://user-images.githubusercontent.com/43863412/165771982-91a11611-9409-4de7-af83-1d28441027db.png)](https://user-images.githubusercontent.com/43863412/165771982-91a11611-9409-4de7-af83-1d28441027db.png)\nI was devastated. My life was ruined. I wanted to die.\n\nJokes aside, I thought that I needed to link the .dylib with my [Xcode](https://developer.apple.com/xcode/) project, resolve the method that I want to look at during the runtime with [LLDB](https://lldb.llvm.org), STEAL the information from it, and apply that in my beloved [Binary Ninja](https://binary.ninja) manually. *That is a Sisyphean labor*.\n\nOf course, [LLDB](https://lldb.llvm.org) is great when it comes to resolving some of the important Objective-C runtime information, such as selectors or NSStrings for example:\n![[research/MacOS/assets/Pasted image 20220429163436.png]]\nIf only I could apply this information to my reverse engineering tool of the choice...\n## An idea comes to mind\nStatic analysis or dynamic analysis, reverse engineering theory...\nNo! I will choose my own destiny. I will make a plugin. A plugin that makes my static analysis \"gigavaxxed\" with the power of dynamic analysis.\n\n![[research/MacOS/assets/Pasted image 20220429191349.png]]\n\n*Note: [Binary Ninja](https://binary.ninja) has an AMAZING set of APIs. Refer to the [docs](https://api.binary.ninja) for more information on them.*\n\nFor a given .dylib function or a .dylib itself, my plugin compiles an [Xcode](https://developer.apple.com/xcode/) project with an altered code that will resolve the function's pointer. Then, it is analyzed in [LLDB](https://lldb.llvm.org) and the runtime information from that is propagated to the [Binary Ninja](https://binary.ninja), where comments are added and variables are renamed (effectively enhancing our static analysis).\n## Time - before one runs away\nOne would say, \"It will take a huge amount of time\".\n\n![[research/MacOS/assets/Pasted image 20220429191449.png]]\n\nI would answer, YES. Dynamic analysis ([LLDB](https://lldb.llvm.org)) itself is costly, not even taking the [Xcode](https://developer.apple.com/xcode/) project building \u0026 running into account. Moreover, the *Big O notation* would probably have died from a heart attack if my python code was EXPOSED to it.\n\nBUT, the time spent is **WORTH IT**. The plugin also runs on a separate thread so it won't bother your analysis.\n\nFor example, the time needed to decorate the whole ***TCC.Framework*** C-like export table using my plugin (tests were done on my M1 MacBook with *99999* Safari tabs open, PyCharm running, and Burp Suite + Chromium devouring my RAM and CPU in the background):\n\nx86_64:  **137** functions decorated, **17.85** minutes elapsed\n\narm64: **137** functions decorated, **11.87** minutes elapsed\n\nClearly shows why arm64 is the future.\n\nFunnily, it also triggered this alert (if somebody could explain to me what happened, I would be very grateful):\n![[research/MacOS/assets/Pasted image 20220429173153.png]]\nAll I was doing is resolving the function's pointer, attaching to it with [LLDB](https://lldb.llvm.org) and breaking at main:\n```objective-c\n#import \u003cFoundation/Foundation.h\u003e\n#import \u003cobjc/runtime.h\u003e\n    \nextern id TCCAccessSetForBundleIdAndCodeRequirement();\n    \nint main(void) {\n    NSLog(@\"POINTER:%p\", TCCAccessSetForBundleIdAndCodeRequirement);\n}\n```\nTCCAccessSetForBundleIdAndCodeRequirement is also mentioned by [Wojciech Regu≈Ça](https://twitter.com/_r3ggi) [here](https://wojciechregula.blog/post/play-the-music-and-bypass-tcc-aka-cve-2020-29621/). Amusing that only resolving that function's pointer triggers such a pop-up.\n\nWhat about the Objective-C methods? I used the following technique:\n```objective-c\n#import \u003cFoundation/Foundation.h\u003e\n#import \u003cobjc/runtime.h\u003e\n\nint main(void) {\n\tClass c = NSClassFromString(@\"AMFIPathValidator_ios\");\n    void* p = method_getImplementation(class_getClassMethod(c, @selector(validateWithError:)));\n    if (p == NULL) {\n        void* p = method_getImplementation(class_getInstanceMethod(c, @selector(validateWithError:)));\n        NSLog(@\"POINTER:%p\", p);\n    }\n    else {\n        NSLog(@\"POINTER:%p\", p);\n    }\n}\n```\n\nBenchmark of ***AppleMobileFileIntegrity.Framework***:\n\nx86_64: **99** methods decorated, **5.93** minutes elapsed\n\nImpressive!\n## Automation is the key\nI coded this simple [LLDB](https://lldb.llvm.org) python script to dump the function and save the PRECIOUS runtime information:\n```python\ndef dump(debugger, command, result, internal_dict):  \n    debugger.HandleCommand('break set -n main')  \n    debugger.HandleCommand('run')  \n    f = open(\"dump.txt\", \"w\")  \n    debugger.SetOutputFileHandle(f, True)  \n    debugger.HandleCommand('disas -a 0x7ffb15479824')\n```\nFor the [Binary Ninja](https://binary.ninja), I created my LLDBDecorator class which inherits from BackgroundTaskThread to enable threading:\n```python\nclass LLDBDecorator(BackgroundTaskThread):  \n    def __init__(self, bv, fnc=\"\"):  \n        self.functions = []  \n        self.results = 0  \n        self.bv = bv  \n        self.fnc = fnc  \n        self.progress_bar = \"\"  \n        BackgroundTaskThread.__init__(self, self.progress_bar, True)  \n  \n    def run(self):  \n        start = time.time()  \n        res = self.lldb_decorate()  \n        end = time.time() - start  \n        log_info(\"[Vulnerizer] [Objective-C] - LLDB decoration ended, {} decorated, {:2f} seconds elapsed\".format(res, end))\n```\nI also coded the ldb_decorate method to set everything up, automate [Xcode](https://developer.apple.com/xcode/) + [LLDB](https://lldb.llvm.org) routines and populate [Binary Ninja](https://binary.ninja) with results:\n```python\ndef lldb_decorate(self):\n\t# ...\n```\nWe can ABUSE python \"TeMpLaTeS\" (f-strings) for the changes in code:\n```python\ncode = f\"\"\"#import \u003cFoundation/Foundation.h\u003e  \n#import \u003cobjc/runtime.h\u003e  \n  \nint main(void) {{  \n    Class c = NSClassFromString(@\"{class_name}\");  \n    void* p = method_getImplementation(class_getClassMethod(c, @selector({selector_name})));  \n    if (p == NULL) {{  \n        void* p = method_getImplementation(class_getInstanceMethod(c, @selector({selector_name})));  \n        NSLog(@\"POINTER:%p\", p);    }}  \n    else {{  \n        NSLog(@\"POINTER:%p\", p);    }}  \n    // NSLog(@\"%@\", [c performSelector: @selector({selector_name})]);  \n}}\"\"\"\n```\n```python\ndump_py = f\"\"\"\ndef dump(debugger, command, result, internal_dict):  \n    debugger.HandleCommand('break set -n main')    debugger.HandleCommand('run')    f = open(\"{os.path.join(dirname, 'dump.txt')}\", \"w\")  \n    debugger.SetOutputFileHandle(f,True)    debugger.HandleCommand('disas -a {pointer}')\"\"\"\n```\nI also added an option for C-like imports (as shown during the TCC benchmark):\n```python\nelif self.fnc == \"exports\":  \n    exports = 1  \n    for sym in self.bv.get_symbols_of_type(SymbolType.FunctionSymbol):  \n        if sym.binding == SymbolBinding.GlobalBinding:  \n            self.functions.append(self.bv.get_functions_by_name(sym.name)[0])\n```\n## Code\nUnfortunately, at the end of the day, my MacBook overheated, malfunctioned, started to burn, and exploded. This is so sad and that is why I couldn't provide the full codebase.\n\nWell, jokes aside, this is still very much work-in-progress and I cannot provide the project code in the state it is right now (please do not HACK and EXPOSE me). I am also confident that many Security Researchers are more experienced than I am, so reimplementing this project shouldn't take a lot of time given the effort and information above (personally did it in two days).\n\nIn the worst case, DM me on [Twitter](https://twitter.com/cr7pt0pl4gu3) for the source code.\n## Grand Finale\nThank you for reading this and I hope you learned something new or at least explored an interesting case study that may push you to your great ideas.\n\nI may also do a second take on this project if it interests people.\n\n@Daniil Nababkin (cr7pt0pl4gu3)","lastmodified":"2022-04-29T17:13:11.036004164Z","tags":null},"/research/MacOS/Reverse-Engineering-and-Demystifying-OS-Private-Frameworks":{"title":"RE and Demystifying *OS Private Frameworks","content":"# [\\~\\~\\~Open .pdf file in a new tab\\~\\~\\~](https://cr7pt0pl4gu3.github.io/research/MacOS/aapl.pdf)\n![[research/MacOS/aapl.pdf]]","lastmodified":"2022-04-29T17:13:11.036004164Z","tags":null}}